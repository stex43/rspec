<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>std::jthread</code>, introduced in C&#43;&#43;20, is a wrapper around <code>std::thread</code>. This way, it has the same functionalities as <code>std::thread</code>, making the substitution really straightforward, while adding two interesting behaviors:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It joins by default in its destructor. If a <code>std::thread</code> was not joined or detached before being destroyed, a call to <code>std::terminate</code> was made. This can’t happen with <code>std::jthread</code>.</p>
</li>
<li>
<p>It can be canceled or stopped in some situations by calling <code>request_stop()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This rule raises an issue as soon as <code>std::thread</code> is used.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void backgroundTask();
int main() {
  std::thread t(backgroundTask); // Noncompliant
  t.join();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void backgroundTask();
int main() {
  std::jthread jt(backgroundTask);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#cp25-prefer-gsljoining_thread-over-stdthread">C&#43;&#43; Core Guidelines CP.25</a> - Prefer "gsl::joining_thread" over "std::thread"</p>
</li>
</ul>
</div>
</div>
</div>