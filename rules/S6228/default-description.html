<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Since integers are usually represented in binary form in computers, it is efficient to check if a given number is a power of two by checking if its  <code>unsigned</code> representation has a single bit set.</p>
</div>
<div class="paragraph">
<p>In C&#43;&#43; such check could be expressed as <code>x &amp; (x-1) == 0</code>. However, the intent of this expression is unclear. Furthermore, it requires to take special care for the value <code>0</code>, which would pass the above check, while not having any bit set and not being a power of two.</p>
</div>
<div class="paragraph">
<p>This check can be expressed more clearly with the <code>std::has_single_bit</code> function template, introduced in C&#43;&#43;20.</p>
</div>
<div class="paragraph">
<p>This rule reports computations that could be replaced with <code>std::has_single_bit</code> .</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void f(unsigned x) {
  if ((x &gt; 0) &amp;&amp; !(x &amp; (x-1))) { // Noncompliant
    // Special algorithm for powers of 2
  }
  // Normal algorithm
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void f(unsigned x) {
  if (std::has_single_bit(x)) {
    // Special algorithm for powers of 2
  }
  // Normal algorithm
}</code></pre>
</div>
</div>
</div>
</div>
</div>