<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In contrast to C printf-like functions, the <code>std::format</code> family of formatting functions provides
a safer, and more robust interface for performing text formatting.</p>
</div>
<div class="paragraph">
<p>Firstly, C++ formatting facilities perform validation of the format string against the type
of the formatted argument. If the validation fails, it is reported as a compilation error
for the calls of <code>std::format</code>, and via exception for  <code>std::vformat</code>.</p>
</div>
<div class="paragraph">
<p>Secondly, the relation between the type and format specifier is more abstract.
In particular, <code>{:d}</code> can be used to format any integer type, regardless of its size and signedness.
Similarly, <code>{:f}</code> works for any floating point type.
Furthermore, <code>{}</code> can be used for any type with default format spec, which makes it usable in the generic context.</p>
</div>
<div class="paragraph">
<p>Finally, the <code>std::format</code> API can be extended to support custom types with the dedicated format specification via
<code>std::formatter</code> specializations.</p>
</div>
<div class="paragraph">
<p>This rule raises issues for calls of the <code>sprintf</code> and <code>snprintf</code> functions that can be replaced by the C++ formatting functions.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void printFunc(FILE* f, char* out, size_t n) {
  sprintf(out, "%u %s", 10u, “text”); // Noncompliant
  std::snprintf(out, n, "%i %% %LG", 10, 10.0L); // Noncompliant

  printf("%i", 10);  // Compliant, no direct remplacement
  std::fprintf(f, "%f", 10.0);  // Compliant, no direct remplacement
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void printFunc(FILE* f, char* out, size_t n) {
  std::format_to(out, “{:d} {:s}”, 10u, text); // Compliant
  // or
  std::format_to(out, “{} {}”, 10u, text); // Compliant

  std::format_to_n(out, ”{:d} % {:G}”, 10, 10.0L); // Compliant
  // or
  std::format_to_n(out, ”{} % {:G}”, 10, 10.0L); // Compliant

  printf("%i", 10);  // Compliant, no direct remplacment
  std::fprintf(f, "%f", 10.0);  // Compliant, no direct remplacment
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>The issue is raised if the format string passed to printf-like function is computed dynamically,
instead of being spelled in the source code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">char const* localizedFormatString(unsigned id);
/* …. */
snprintf(buffer, localizedFormatString(123), 10, 20)</code></pre>
</div>
</div>
<div class="paragraph">
<p>While <code>std::vformat</code> may be used in such cases, it will require an change of the format string,
which may not be actionable.</p>
</div>
</div>
</div>
</div>