<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The class <code>std::optional</code> stores an optional value: a <code>std::optional&lt;T&gt;</code> can either contain a value of type <code>T</code> or be empty. One way to access the value of a non-empty optional is the <code>operator*</code>, making an optional look like a pointer.</p>
</div>
<div class="paragraph">
<p>However, the similarity ends there. In particular, the preferred way to assign a value to an optional is to assign it directly (as opposed to assigning it to the dereferenced value or to the result of the function <code>value()</code>). In that case, the assignment works even if the optional does not have a prior value.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void g(std::optional&lt;int&gt; &amp;val, bool b) {
    if (b) {
      *val = 314; // Noncompliant, will throw if the optional was previously empty
    } else {
      val.value() = 42; // Noncompliant, will throw if the optional was previously empty
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void g(std::optional&lt;int&gt; &amp;val, bool b) {
    if (b) {
      val = 314; // Compliant
    } else {
      val = 42; // Compliant
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>