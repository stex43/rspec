<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>C&#43;&#43;20 introduces a new text formatting API with the <code>&lt;format&gt;</code> header,
joining the <code>printf</code> family of functions&#8201;&#8212;&#8201;inherited from C&#8201;&#8212;&#8201;and <code>iostreams</code>.
<code>std::format</code> combines the convenience of <code>printf</code>, separating formatting and
arguments, with the type-safety of <code>iostreams</code>.</p>
</div>
<div class="paragraph">
<p>Before C&#43;&#43;20, if you wanted to format an output stream, you had to use standard manipulators that control the output streams.
This approach is very verbose, is often stateful, and is not thread-safe. That is why we recommend replacing them with <code>std::format</code>
when possible.</p>
</div>
<div class="paragraph">
<p>Some manipulators will have a temporary effect on the output. For example, <code>std::setw</code>. This is due to the resetting of the width property of the stream when most of the <code>operator&lt;&lt;</code>is called.
Other manipulators will have a lasting effect on the output. For example, <code>std::boolalpha</code>. It will set the <code>boolalpha</code> flag of the outputstream without resetting it.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when an output stream is used with standard manipulators to output a formattable type in a way that can be replaced by <code>std::format</code>.
You should be careful to avoid undesirable side effects when replacing a manipulator with lasting effects.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void printBool(bool b) {
  std::cout &lt;&lt; std::boolalpha &lt;&lt; b; // Noncompliant
}

void printInt(int b) {
  std::cout &lt;&lt; std::setfill('*') &lt;&lt; std::setw(5) &lt;&lt; b; // Noncompliant
}

int main() {
  printInt(10);
  printBool(true);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void printBool(bool b) {
  // Compliant, be aware of the side effect of not setting the boolalpha flag
  std::cout &lt;&lt; std::format("{}", b);
}

void printInt(int b) {
  // Compliant, no side effect because setw has a temporary effect
  std::cout &lt;&lt; std::format("{:*&gt;5}", b);
}

void printQuoted(std::string_view s) {
  // Compliant, no simple format-based alternative
  std::cout &lt;&lt; std::quoted(s, '$', '-');
}

void setFlags() {
  // Compliant, the intention is to set the flags and not to output
  std::cout &lt;&lt; std::boolalpha &lt;&lt; std::showbase;
}

int main() {
  printInt(10);
  printBool(true);
  printQuoted("10$");
  setFlags();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>Manipulators that don&#8217;t have a direct equivalent in the format library like <code>std::quoted</code>, <code>std::put_money</code>, etc.</p>
</div>
</div>
</div>
</div>